#light

namespace FsCheck

[<AutoOpen>]
module Generator

open Random
open Reflect
open System
open System.Reflection
open System.Collections.Generic
open Microsoft.FSharp.Reflection
 
type internal IGen = 
    abstract AsGenObject : Gen<obj>
    
///Generator of a random value, based on a size parameter and a randomly generated int.
and Gen<'a> = 
    Gen of (int -> StdGen -> 'a) 
        ///map the given function to the value in the generator, yielding a new generator of the result type.  
        member x.Map<'a,'b> (f: 'a -> 'b) : Gen<'b> = match x with (Gen g) -> Gen (fun n r -> f <| g n r)
    interface IGen with
        member x.AsGenObject = x.Map box
        //match x with (Gen g) -> Gen (fun n r -> g n r |> box)

///Obtain the current size. sized g calls g, passing it the current size as a parameter.
let sized fgen = Gen (fun n r -> let (Gen m) = fgen n in m n r)

///Override the current size of the test. resize n g invokes generator g with size parameter n.
let resize n (Gen m) = Gen (fun _ r -> m n r)

///Default generator that generates a random number generator. Useful for starting off the process
///of generating a random value.
let rand = Gen (fun n r -> r)

///Generates a value out of the generator with maximum size n.
let generate n rnd (Gen m) = 
    let size,rnd' = range (0,n) rnd
    m size rnd'

///The workflow type for generators.
type GenBuilder () =
    member b.Return(a) : Gen<_> = 
        Gen (fun n r -> a)
    member b.Bind((Gen m) : Gen<_>, k : _ -> Gen<_>) : Gen<_> = 
        Gen (fun n r0 -> let r1,r2 = split r0
                         let (Gen m') = k (m n r1) 
                         m' n r2)                                      
    //member b.Let(p, rest) : Gen<_> = rest p
    //not so sure about this one...should delay executing until just before it is executed,
    //for side-effects. Examples are usually like = fun () -> runGen (f ())
    member b.Delay(f : unit -> Gen<_>) : Gen<_> = 
        Gen (fun n r -> match f() with (Gen g) -> g n r )
    member b.TryFinally(Gen m,handler ) = 
        Gen (fun n r -> try m n r finally handler)
    member b.TryWith(Gen m, handler) = 
        Gen (fun n r -> try m n r with e -> handler e)
    member b.Using (a, k) =  //'a * ('a -> Gen<'b>) -> Gen<'b> when 'a :> System.IDisposable
        use disposea = a
        k disposea

///The workflow function for generators, e.g. gen { ... }
let gen = GenBuilder()

///Generates an integer between l and h, inclusive.
///Note to QuickCheck users: this function is more general in QuickCheck, generating a Random a.
let choose (l, h) = rand.Map (range (l,h) >> fst) 

///Build a generator that randomly generates one of the values in the given list.
let elements xs = (choose (0, (List.length xs)-1) ).Map(List.nth xs)

///Build a generator that generates a value from one of the generators in the given list, with
///equal probability.
let oneof gens = gen.Bind(elements gens, fun x -> x)

///Build a generator that generates a value from one of the generators in the given list, with
///given probabilities.
let frequency xs = 
    let tot = List.sum_by (fun x -> x) (List.map fst xs)
    let rec pick n ys = match ys with
                        | (k,x)::xs -> if n<=k then x else pick (n-k) xs
                        | _ -> raise (ArgumentException("Bug in frequency function"))
    in gen.Bind(choose (1,tot), fun n -> pick n xs)  

///Lift the given function over values to a function over generators of those values.
let liftGen f = fun a -> gen {  let! a' = a
                                return f a' }

///Lift the given function over values to a function over generators of those values.
let liftGen2 f = fun a b -> gen {   let! a' = a
                                    let! b' = b
                                    return f a' b' }
                                    
///Build a generator that generates a 2-tuple of the values generated by the given generator.
let two g = liftGen2 (fun a b -> (a,b)) g g

///Lift the given function over values to a function over generators of those values.
let liftGen3 f = fun a b c -> gen { let! a' = a
                                    let! b' = b
                                    let! c' = c
                                    return f a' b' c' }

///Build a generator that generates a 3-tuple of the values generated by the given generator.
let three g = liftGen3 (fun a b c -> (a,b,c)) g g g

///Lift the given function over values to a function over generators of those values.
let liftGen4 f = fun a b c d -> gen {   let! a' = a
                                        let! b' = b
                                        let! c' = c
                                        let! d' = d
                                        return f a' b' c' d' }

///Build a generator that generates a 4-tuple of the values generated by the given generator.
let four g = liftGen4 (fun a b c d -> (a,b,c,d)) g g g g

let private fraction (a:int) (b:int) (c:int) = 
    double a + ( double b / abs (double c)) + 1.0 

///Sequence the given list of generators into a generator of a list.
///Note to QuickCheck users: this is monadic sequence, which cannot be expressed generally in F#.
let rec sequence l = match l with
                            | [] -> gen { return [] }
                            | c::cs -> gen {let! x = c
                                            let! xs = sequence cs
                                            return  x::xs } 

///Generates a list of given length, containing values generated by the given generator.
///vector g n generates a list of n t's, if t is the type that g generates.
let vector arbitrary n = sequence [ for i in 1..n -> arbitrary ]

let private promote f = Gen (fun n r -> fun a -> let (Gen m) = f a in m n r)

///Basic co-arbitrary generator, which is dependent on an int.
let variant = fun v (Gen m) ->
    let rec rands r0 = seq { let r1,r2 = split r0 in yield! Seq.cons r1 (rands r2) } 
    Gen (fun n r -> m n (Seq.nth (v+1) (rands r)))

///A collection of default generators.
type Gen =
    ///Generates (), of hte unit type.
    static member Unit = gen { return () }
    ///Generates arbitrary bools
    static member Bool = elements [true; false]
    ///Generates arbitrary ints, between -n and n where n is the test size.
    static member Int = sized <| fun n -> choose (-n,n)
    ///Generates arbitrary floats, NaN included fairly frequently.
    static member Float = liftGen3 fraction Gen.Int Gen.Int Gen.Int
    ///Generates arbitrary chars, between ASCII codes Char.MinValue and 127.
    static member Char = (choose (32, 127)).Map char 
    ///Generates arbitrary strings, which are lists of chars generated by Char.
    static member String = (Gen.List(Gen.Char)).Map (fun chars -> new String(List.to_array chars))
    ///Generates arbitrary objects, which are generated by Unit, Bool, Char, Int, or String and then cast.
    static member Object = 
        oneof [ (Gen.Unit :> IGen).AsGenObject;
                (Gen.Bool :> IGen).AsGenObject;
                (Gen.Char :> IGen).AsGenObject;
                (Gen.String :> IGen).AsGenObject ]
    ///Genereate a 2-tuple consisting of values generated out of the given generators.
    static member Tuple(a:Gen<'a>,b:Gen<'b>) = liftGen2 (fun x y -> (x,y)) a b
    ///Genereate a 3-tuple consisting of values generated out of the given generators.
    static member Tuple(a:Gen<'a>,b:Gen<'b>,c:Gen<'c>) = liftGen3 (fun x y z -> (x,y,z)) a b c 
    ///Genereate a 4-tuple consisting of values generated out of the given generators.
    static member Tuple(a:Gen<'a>,b:Gen<'b>,c:Gen<'c>,d:Gen<'d>) = liftGen4 (fun x y z w -> (x,y,z,w)) a b c d
    ///Generate an option value, based on the value generated by the given generator.
    static member Option(a) = 
        let arbOption size = 
            match size with
                | 0 -> gen { return None }
                | n -> (a |> resize (n-1)).Map(Some) 
        in sized arbOption
    ///Generate a list of values generated by the given generator. The size of the list is between 0 and the test size + 1.
    static member List<'a>(a : Gen<'a>) : Gen<list<'a>> = sized (fun n -> gen.Bind(choose(0,n+1 (*avoid empties*)), vector a))
    ///Generate a function value, based on the given co-arbitrary generator and result generator.
    static member Arrow(coa,genb) = promote (fun a -> coa a genb)  

///A collection of default coarbitrary generators.
///These are used to generate (pure) functions from coarbitrary type -> arbitary type. In many ways,
///these can be thought of as doing the reverse of their respective arbitrary type: whereas an arbitrary
///for a type maps an arbitrary int to an arbitrary value of that type, the co-arbitrary generator
///maps an arbitrary value of the type to an int (if this is always the same int for the same source value,
///the resulting generated function is pure).
type Co =
    ///Coarbitrary generator for unit 
    static member Unit a = variant 0
    ///Coarbitrary generator for bool 
    static member Bool b = if b then variant 0 else variant 1
    ///Coarbitrary generator for int 
    static member Int n = variant (if n >= 0 then 2*n else 2*(-n) + 1)
    ///Coarbitrary generator for char 
    static member Char c = Co.Int (int c)
    ///Coarbitrary generator for string 
    static member String s = Co.List (Co.Char) s
    ///Coarbitrary generator for 2-tuple                         
    static member Tuple (coa,cob) (a,b) = coa a >> cob b
    ///Coarbitrary generator for 3-tuple
    static member Tuple (coa,cob,coc) (a,b,c) = coa a >> cob b >> coc c
    ///Coarbitrary generator for 4-tuple 
    static member Tuple (coa,cob,coc,cod) (a,b,c,d) = 
          coa a >> cob b >> coc c >> cod d    
    ///Coarbitrary generator for float  
    static member Float (fl:float) = //convert float 10.345 to 10345 * 10^-3
        let d1 = sprintf "%g" fl
        let spl = d1.Split([|'.'|])
        let m = if (spl.Length > 1) then spl.[1].Length else 0
        let decodeFloat = (fl * float m |> int, m )
        Co.Tuple(Co.Int, Co.Int) <| decodeFloat
    ///Coarbitrary generator for option
    static member Option coa a =
          match a with 
            | None -> variant 0
            | Some y -> variant 1 >> coa y 
    ///Coarbitrary generator for list                              
    static member List coa l = match l with
                                | [] -> variant 0
                                | x::xs -> coa x << variant 1 << Co.List coa xs
    ///Coarbitrary generator for functions
    static member Arrow (gena,cob) f (gn:Gen<_>) = 
        gen { let! x = gena
              return! cob (f x) gn }
              
//parametrized active pattern that recognizes generic types with generic type definitions equal to the first paramater, 
//and that returns the generic type parameters of the generic type.
let private (|GenericTypeDef|_|) (p:Type) (t:Type) = 
    try
        let generic = t.GetGenericTypeDefinition() 
        if p.Equals(generic) then Some(t.GetGenericArguments()) else None
    with _ -> None

let private findGenerators = 
    let addMethods l (t:Type) =
        t.GetMethods((BindingFlags.Static ||| BindingFlags.Public)) |>
        Seq.fold (fun l m ->
            //let returnType = m.ReturnType
            let gen = typedefof<Gen<_>>
            let s = gen.GetGenericArguments
            match m.ReturnType with
                | GenericTypeDef gen args -> 
                    let typeToAdd = 
                        if args.[0].IsGenericType then 
                            if m.GetParameters().Length <> args.[0].GetGenericArguments().Length then
                                failwithf "Error in %A: Generator methods _must_ take a generator as parameter for each generic argument of the type-to-generate." m
                            args.[0].GetGenericTypeDefinition() 
                        else 
                            args.[0]
                    (typeToAdd, m) :: l   
                | _ -> l
            ) l
    addMethods []

///The currently registered generators, by the type they are generating.
let private generators = new Dictionary<_,_>()

///Register all the generators for types defined by static members of the given class type. Throws an exception if
///any of them are already registered.
let registerGenerators t = findGenerators t |> Seq.iter generators.Add//(fun (t,mi) -> generators.Add(t, mi); printfn "%A" (t,mi))

///Register all the generators for types defined by static members of the given class type. If
///any of them are already registered, the old ones are overwritten by the given ones.
let overwriteGenerators t = findGenerators t |> Seq.iter (fun (t,mi) -> generators.[t] <- mi)

do registerGenerators (typeof<Gen>)


//----------contirbution by Neil. Should be integrated with existing generators; currently given
//generators for chars etc are not honored, and neither are user defined primitive types.
let debugNeilCheck = false

// first function given is impure
type NeilGen = (int -> int -> int) -> int -> obj

let private genMap : Ref<Map<string, Lazy<NeilGen>>> = ref (Map.empty)

// Compute which types are possible children of this type
// Helps make union generation terminate quicker
let private containedTypes (t : Type) : list<Type> = [] // TODO

let rec private getNeilGen (t : Type) : Lazy<NeilGen> =
        let ts = t.ToString()
        match (!genMap).TryFind ts with
        | Some v -> v
        | None ->
            let res = lazy neilGen t
            genMap := (!genMap).Add (ts,res)
            res

    //this finds the generators for each of the types, then chooses one element for each type (so, a product type like tuples)
    and productGen (ts : list<Type>) =
        let gs = [| for t in ts -> getNeilGen t |]
        let n = gs.Length
        fun next size -> [| for g in gs -> g.Value next ((size / n) - 1) |]

    and intGen next size = next (-size) size 
    and charGen next size = Char.chr (next 32 127)

    and neilGen (t : Type) : NeilGen =
        if t.IsArray then
            let t2 = t.GetElementType()
            let inner = getNeilGen t2
            fun next size ->
                let n = max 0 (next 0 size)
                let res = Array.CreateInstance(t2, n)
                for i in 0 .. n-1 do
                    res.SetValue(inner.Value next (size - 1), i)
                box res

        //this is for lists; based on the generator for arrays (turns an array into a list using reflection)
        elif genericTypeEq t (typeof<List<unit>>) then
            let t2 = (t.GetGenericArguments()).[0]
            let inner = getNeilGen (t2.MakeArrayType())
            
            let modu = t.Assembly.GetType "Microsoft.FSharp.Collections.ListModule"
            let meth = modu.GetMethod "of_array"
            let of_array = meth.MakeGenericMethod [| t2 |]
            
            fun next size -> box <| of_array.Invoke(null, [| inner.Value next size |])

        
        elif isTupleType t then
            let ts = match FSharpType.IsTuple t with 
                     | true -> FSharpType.GetTupleElements t |> List.of_seq
                     | _ -> failwith "not a tuple, but should be"
            let g = productGen ts
            let create = FSharpValue.PrecomputeRecordConstructor t
            fun next size -> create (g next size)


        elif isRecordType t then
            let g = productGen [ for pi in getRecordFields t -> pi.PropertyType ]
            let create = getRecordConstructor t
            fun next size -> create (g next size)


        elif isUnionType t then
            // figure out the "size" of a union
            // 0 = nullary, 1 = non-recursive, 2 = recursive
            let unionSize (ts : list<Type>) : int =
                if ts.IsEmpty then 0 else
                    let tsStar = List.concat (ts :: List.map containedTypes ts) //containedTypes is not implemented, always returns[]
                    if List.exists(fun (x : Type) -> x.ToString() = t.ToString()) tsStar then 2 else 1
                    //so this wil either return 0 or 1, never 2...
                    
            let unionGen create ts =
                let g = productGen ts
                fun next size -> create (g next size)

            let gs = [| for _,(_,fields,create,_) in getUnionCases t -> unionSize fields, unionGen create fields |]
            let lowest = Array.reduce_left min <| Array.map fst gs
            let small = [| for i,g in gs do if i = lowest then yield g |]
            let large = [| for _,g in gs -> g |]
            fun next size ->
                let gs = if size <= 0 then small else large
                gs.[next 0 (gs.Length-1)] next size


        elif t = typeof<string> then
            let inner = getNeilGen (typeof<char[]>)
            fun next size -> box <| new String(unbox (inner.Value next size) : char[])

        elif t = typeof<float> then
            fun next size ->
                let fraction a b c = double a + ( double b / abs (double c)) + 1.0 
                let value() = intGen next size
                box <| fraction (value()) (value()) (value())

        elif t = typeof<unit> then
            fun next size -> box ()
        elif t = typeof<int> then
            fun next size -> box <| intGen next size
        elif t = typeof<char> then
            fun next size -> box <| charGen next size
        else
            failwithf "Geneflect: type not handled %A" t

and private geneflectObj (t : Type) : Gen<obj> = Gen <| fun size stdgen ->
    if debugNeilCheck then printfn "%A" size
    let gen = ref stdgen
    let next low high =
        let v,g = range (low,high) !gen
        gen := g
        v
    (getNeilGen t).Value next size

//let geneflect() : Gen<'a> = (geneflectObj (typeof<'a>)).Map unbox
//----------------end of contributed part-------------------

and internal getGenerator (genericMap:IDictionary<_,_>) (t:Type)  =
    if t.IsGenericParameter then
        //special code for when a generic parameter needs to be generated
        Gen.Object |> box
        //the code below chooses one generator type per generic type and then sticks with it
        //however, because of the difference in behavior between methodinfo.GetGenericArgs (return a name for
        //generic args) and FSharpType.GetFunctionElements (returns obj for generic args), the code below
        //causes a discrepancy. Now both will generate Whatever<obj>. 
//        if genericMap.ContainsKey(t) then 
//            genericMap.[t]
//        else
//            let newGenerator =  
//                [ Gen.Unit |> box;
//                  Gen.Bool |> box;
//                  Gen.Char |> box;
//                  Gen.String |> box ]
//                |> elements
//                |> generate 0 (newSeed())
//            genericMap.Add(t, newGenerator)
//            newGenerator 
    else
        match generators.TryGetValue(t) with 
        |(true, mi) -> mi.Invoke(null, null) //we found a specific generator, use that
        |(false, _) -> 
            if t.IsGenericType then
                match generators.TryGetValue(t.GetGenericTypeDefinition()) with
                |(true, mi) -> 
                    //found a generic generator
                    let args = t.GetGenericArguments() |> Array.map (getGenerator genericMap)
                    let typeargs = args |> Array.map (fun o -> o.GetType().GetGenericArguments().[0])
                    let mi = if mi.ContainsGenericParameters then mi.MakeGenericMethod(typeargs) else mi
                    mi.Invoke(null, args)
                |(false, _) -> //we got nothing. Geneflect the thing.
                    geneflectObj t |> box 
            else
                geneflectObj t |> box
                
        
